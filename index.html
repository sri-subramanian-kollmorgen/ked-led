<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Button + LED + Log (Browser Version)</title>
<style>
  :root {
    --bg: #111;
    --panel: #1e1e1e;
    --text: #e6e6e6;
    --muted: #9aa0a6;
    --led-off: #2b2b2b;
    --outline: #101010;
  }
  body { margin:0; font-family: system-ui, Segoe UI, Roboto, Arial, sans-serif; background:var(--bg); color:var(--text); }
  .wrap { max-width: 820px; margin: 2rem auto; padding: 1rem; }
  .card { background: var(--panel); border-radius: 12px; padding: 16px; box-shadow: 0 2px 10px rgba(0,0,0,.35); }
  .row { display:flex; gap:16px; align-items:center; }
  .led {
    width: 90px; height: 90px; border-radius: 50%;
    background: var(--led-off); border: 2px solid var(--outline);
    box-shadow: inset 0 0 10px rgba(0,0,0,.6);
    transition: background-color .12s linear, opacity .1s linear;
  }
  button {
    background: #2d6cdf; color:white; border:none; padding: 10px 16px;
    border-radius: 8px; font-size: 15px; cursor: pointer;
  }
  button:active { transform: translateY(1px); }
  textarea {
    width: 100%; height: 220px; background:#121212; color:#d7d7d7;
    border: 1px solid #2a2a2a; border-radius: 8px; padding:10px; resize: vertical;
  }
  .muted { color: var(--muted); font-size: 13px; }
</style>
</head>
<body>
  <div class="wrap">
    <h1>Two‑Stage LED State Machine (Web)</h1>
    <div class="card">
      <div class="row">
        <div id="led" class="led" aria-label="LED"></div>
        <button id="btn" aria-label="Control Button">Button</button>
      </div>
      <p class="muted" id="hint"></p>
      <textarea id="log" readonly></textarea>
    </div>
  </div>

<script>
/** -----------------------------
 *  Timings / behavior
 * ------------------------------*/
const ACTIVATION_HOLD_MS   = 10_000;     // 10s hold → Activated
const SELECTION_HOLD_MS    = 5_000;      // 5s hold (from Activated) → Selection
const ACTIVATED_BLINK_MS   = 100;        // Fast blink during Activated
const SELECTION_PHASE_MS   = 5_000;      // 5s per color during Selection
const SELECTION_BLINK_MS   = 500;        // Blink interval during Selection

const COLORS = ["red", "green", "yellow"];

/** -----------------------------
 *  Elements
 * ------------------------------*/
const ledEl  = document.getElementById('led');
const btnEl  = document.getElementById('btn');
const logEl  = document.getElementById('log');
const hintEl = document.getElementById('hint');

/** -----------------------------
 *  State
 * ------------------------------*/
let state = "idle"; // "idle" | "activated" | "selection" | "final"
let pressStart = null;
let pressing = false;

let activationColor = localStorage.getItem('activationColor') || "red";
let blinkTimer = null;     // for blinking
let phaseTimer = null;     // for selection color phases
let holdCheckTimer = null; // for polling hold thresholds

let currentCycleIndex = 0;
let currentPhaseColor = "red";
let ledOn = false;

/** -----------------------------
 *  Logging / helpers
 * ------------------------------*/
function log(msg) {
  const ts = new Date().toLocaleTimeString();
  logEl.value += `[${ts}] ${msg}\n`;
  logEl.scrollTop = logEl.scrollHeight;
}
function setLED(color) {
  // solid color
  stopBlink();
  ledEl.style.background = color;
}
function setLEDOff() {
  stopBlink();
  ledEl.style.background = getComputedStyle(document.documentElement).getPropertyValue('--led-off');
}
function blink(color, intervalMs) {
  stopBlink();
  currentPhaseColor = color; // also remember what we're "showing"
  ledOn = false;
  ledEl.style.background = getComputedStyle(document.documentElement).getPropertyValue('--led-off');
  blinkTimer = setInterval(() => {
    ledOn = !ledOn;
    ledEl.style.background = ledOn ? color :
      getComputedStyle(document.documentElement).getPropertyValue('--led-off');
  }, intervalMs);
}
function stopBlink() {
  if (blinkTimer) { clearInterval(blinkTimer); blinkTimer = null; }
}

/** -----------------------------
 *  Hints (dynamic help)
 * ------------------------------*/
function updateHint() {
  hintEl.textContent =
    `Hold ${ACTIVATION_HOLD_MS/1000}s to activate (fast‑blink ${capitalize(activationColor)}). `
    + `From Activated, hold ${SELECTION_HOLD_MS/1000}s to enter Selection (R→G→Y, 5s each). `
    + `Release during Selection to choose the current color (solid).`;
}
function capitalize(s){ return s.charAt(0).toUpperCase()+s.slice(1); }

/** -----------------------------
 *  State transitions
 * ------------------------------*/
function enterActivated() {
  clearTimers();
  state = "activated";
  blink(activationColor, ACTIVATED_BLINK_MS);
  log(`Activated: fast blinking ${activationColor} (persists after release).`);
}

function enterSelection() {
  clearTimers();
  state = "selection";
  currentCycleIndex = 0;
  log("Selection: cycling Red → Green → Yellow (5s each; blinking). Release to choose.");
  startSelectionPhase();
}

function startSelectionPhase() {
  currentPhaseColor = COLORS[currentCycleIndex % COLORS.length];
  blink(currentPhaseColor, SELECTION_BLINK_MS);
  phaseTimer = setTimeout(() => {
    if (state !== "selection") return;
    currentCycleIndex = (currentCycleIndex + 1) % COLORS.length;
    startSelectionPhase();
  }, SELECTION_PHASE_MS);
}

function finalizeSelection() {
  const chosen = currentPhaseColor;
  clearTimers();
  state = "final";
  setLED(chosen);
  activationColor = chosen;
  localStorage.setItem('activationColor', activationColor);
  log(`Selection complete: LED set solid ${chosen}. Activation color updated to ${chosen}.`);
  updateHint();
}

function clearTimers() {
  if (holdCheckTimer) { clearTimeout(holdCheckTimer); holdCheckTimer = null; }
  if (phaseTimer)     { clearTimeout(phaseTimer);     phaseTimer = null; }
  stopBlink();
}

/** -----------------------------
 *  Hold‑checking logic
 * ------------------------------*/
function startHoldPolling() {
  // Poll every 100ms to see if thresholds are reached
  const poll = () => {
    if (!pressing) return;
    const held = performance.now() - pressStart;

    if (state === "idle" || state === "final") {
      if (held >= ACTIVATION_HOLD_MS) {
        enterActivated();
        return; // remain activated even if button is still held
      }
    } else if (state === "activated") {
      if (held >= SELECTION_HOLD_MS) {
        enterSelection();
        return;
      }
    }
    holdCheckTimer = setTimeout(poll, 100);
  };
  poll();
}

/** -----------------------------
 *  Button events
 * ------------------------------*/
btnEl.addEventListener('mousedown', () => {
  if (pressing) return;
  pressing = true;
  pressStart = performance.now();
  log(`Pressed (state=${state}).`);
  startHoldPolling();
});

btnEl.addEventListener('mouseup', () => {
  if (!pressing) return;
  pressing = false;
  const held = (performance.now() - pressStart) / 1000;
  log(`Released after ${held.toFixed(2)}s (state=${state}).`);
  // In selection: releasing finalizes chosen color
  if (state === "selection") {
    finalizeSelection();
  }
  // In activated: release does nothing (fast blink persists)
  // In idle/final: release before 10s does nothing
});

/** -----------------------------
 *  Init
 * ------------------------------*/
updateHint();
log("Ready.");
if (state === "idle") setLEDOff();
</script>
</body>
</html>
